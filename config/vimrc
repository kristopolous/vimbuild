function FoldBrace()
	if getline(v:lnum+1)[0] == '{'
		return '>1'
	endif
	if getline(v:lnum)[0] == '}'
		return '<1'
	endif
	return foldlevel(v:lnum-1)
endfunction

" function AckExpand(term)
"	execute 'Ack' expand('<cword>')
"endfunction

" Try to get sensible omni complete that shows up when you want it to.
function! Mosh_Tab_Or_Complete()
	if col('.')>1 && strpart( getline('.'), col('.')-2, 3 ) =~ '^[:.\>]'
		return "\<C-X>\<C-O>"
	else
		return "\<Tab>"
endfunction

if v:progname =~? "evim"
  finish
endif

" This must be first, because it changes other options as a side effect.
set nocompatible
set showmatch
set nu
set nocp

" For remote editing...
set cmdheight=2

filetype plugin on

set tags+=~/.vim/systags

" use both cscope and ctag for 'ctrl-]', ':ta', and 'vim -t'
set cscopetag

" check cscope for definition of a symbol before checking ctags: set to 1
" if you want the reverse search order.
set csto=0

" add any cscope database in current directory
if filereadable("cscope.out")
  cs add cscope.out  
  " else add the database pointed to by environment variable 
elseif $CSCOPE_DB != ""
  cs add $CSCOPE_DB
endif

" show msg when any other cscope db added
set cscopeverbose  

" Try to be aggressively 2 spaces.
set tabstop=2
set shiftwidth=2
set expandtab
set foldexpr=FoldBrace()
set foldmethod=expr

" No screen flash, no beep, no nothing.
set visualbell t_vb=

set backup		" keep a backup file

" allow backspacing over everything in insert mode
set backspace=indent,eol,start
set history=50		" keep 50 lines of command line history
set ruler		" show the cursor position all the time
set showcmd		" display incomplete commands
set incsearch		" do incremental searching
set fdc=1
set foldlevel=10

" mouse level things ... 
" try to use the scroll wheel and mouse focus magically
" only when it makes sense.  This is a hard thing to get right.
set ttymouse=xterm2
set mouse=n
set scrolloff=2
set scrolljump=1
set t_Co=256
syntax on
set hlsearch

" For remote editing (ssh://..) set a default view
let g:netrw_browse_split=3

""""""""""""" My cscope/vim key mappings
"
" The following maps all invoke one of the following cscope search types:
"
"   's'   symbol: find all references to the token under cursor
"   'g'   global: find global definition(s) of the token under cursor
"   'c'   calls:  find all calls to the function name under cursor
"   't'   text:   find all instances of the text under cursor
"   'e'   egrep:  egrep search for the word under cursor
"   'f'   file:   open the filename under cursor
"   'i'   includes: find files that include the filename under cursor
"   'd'   called: find functions that function under cursor calls
"
" Below are three sets of the maps: one set that just jumps to your
" search result, one that splits the existing vim window horizontally and
" diplays your search result in the new window, and one that does the same
" thing, but does a vertical split instead (vim 6 only).
"
" I've used CTRL-\ and CTRL-@ as the starting keys for these maps, as it's
" unlikely that you need their default mappings (CTRL-\'s default use is
" as part of CTRL-\ CTRL-N typemap, which basically just does the same
" thing as hitting 'escape': CTRL-@ doesn't seem to have any default use).
" If you don't like using 'CTRL-@' or CTRL-\, , you can change some or all
" of these maps to use other keys.  One likely candidate is 'CTRL-_'
" (which also maps to CTRL-/, which is easier to type).  By default it is
" used to switch between Hebrew and English keyboard mode.
"
" All of the maps involving the <cfile> macro use '^<cfile>$': this is so
" that searches over '#include <time.h>" return only references to
" 'time.h', and not 'sys/time.h', etc. (by default cscope will return all
" files that contain 'time.h' as part of their name).


" To do the first type of search, hit 'CTRL-\', followed by one of the
" cscope search types above (s,g,c,t,e,f,i,d).  The result of your cscope
" search will be displayed in the current window.  You can use CTRL-T to
" go back to where you were before the search.  
"

nmap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR>	
nmap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR>	
nmap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR>	
nmap <C-\>t :cs find t <C-R>=expand("<cword>")<CR><CR>	
nmap <C-\>e :cs find e <C-R>=expand("<cword>")<CR><CR>	
nmap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR>	
nmap <C-\>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
nmap <C-\>d :cs find d <C-R>=expand("<cword>")<CR><CR>	


" Using 'CTRL-spacebar' (intepreted as CTRL-@ by vim) then a search type
" makes the vim window split horizontally, with search result displayed in
" the new window.
"
" (Note: earlier versions of vim may not have the :scs command, but it
" can be simulated roughly via:
"    nmap <C-@>s <C-W><C-S> :cs find s <C-R>=expand("<cword>")<CR><CR>	

nmap <C-@>s :scs find s <C-R>=expand("<cword>")<CR><CR>	
nmap <C-@>g :scs find g <C-R>=expand("<cword>")<CR><CR>	
nmap <F3> :scs find g <C-R>=expand("<cword>")<CR><CR>	
nmap <C-@>c :scs find c <C-R>=expand("<cword>")<CR><CR>	
nmap <C-@>t :scs find t <C-R>=expand("<cword>")<CR><CR>	
nmap <C-@>e :scs find e <C-R>=expand("<cword>")<CR><CR>	
nmap <C-@>f :scs find f <C-R>=expand("<cfile>")<CR><CR>	
nmap <C-@>i :scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>	
nmap <C-@>d :scs find d <C-R>=expand("<cword>")<CR><CR>	


" Hitting CTRL-space *twice* before the search type does a vertical 
" split instead of a horizontal one (vim 6 and up only)
"
" (Note: you may wish to put a 'set splitright' in your .vimrc
" if you prefer the new window on the right instead of the left

nmap <C-@><C-@>s :vert scs find s <C-R>=expand("<cword>")<CR><CR>
nmap <C-@><C-@>g :vert scs find g <C-R>=expand("<cword>")<CR><CR>
nmap <C-@><C-@>c :vert scs find c <C-R>=expand("<cword>")<CR><CR>
nmap <C-@><C-@>t :vert scs find t <C-R>=expand("<cword>")<CR><CR>
nmap <C-@><C-@>e :vert scs find e <C-R>=expand("<cword>")<CR><CR>
nmap <C-@><C-@>f :vert scs find f <C-R>=expand("<cfile>")<CR><CR>	
nmap <C-@><C-@>i :vert scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>	
nmap <C-@><C-@>d :vert scs find d <C-R>=expand("<cword>")<CR><CR>


inoremap <Tab> <C-R>=Mosh_Tab_Or_Complete()<CR>
map <C-F12> :!ctags -R --c++-kinds=+pl --fields=+iaS --extra=+q .<CR>

" Pan through tabs with F11 and F12
nnoremap <F12> :tabn<cr>
nnoremap <F11> :tabp<cr>

" Short-wire writing and closing of buffers
nnoremap q :q<cr>
nnoremap w :w<cr>

" nnoremap <silent> <C-T> :ConqueTerm zsh<CR>

" Have some jump keys for going around panes
nnoremap <C-Left> <C-W>h
nnoremap <C-Right> <C-W>l
nnoremap <C-Up> <C-W>k
nnoremap <C-Down> <C-W>j
nnoremap <M-Down> <C-W>+
nnoremap <M-Up> <C-W>-
nnoremap <M-Left> <C-W><
nnoremap <M-Right> <C-W>>
" noremap <F4> :call AckExpand(expand('<cword>'))<cr>
nmap <C-b> :tabnew <C-d>
imap <C-b> <ESC>:tabnew <C-d>

nmap <C-J> :cn <cr>
imap <C-J> <ESC>:cn <cr>

nmap <C-K> :cp <cr>
imap <C-K> <ESC>:cp <cr>

" Map some f keys for makefile style development
nmap <F6> :w<cr>:make 
map <F6> :w<cr>:make 
imap <F6> <ESC>:w<cr>make 

nnoremap <silent> <F4> :cn<cr>

" make comma and dot expand and collapse folds
nmap , zc
map , zc

nmap . zO
map . zO

nnoremap <silent> <F8> :NERDTreeToggle<CR><C-w>h<C-w><C-w>h<C-w>h
nnoremap <silent> <F7> :TlistToggle<CR><C-w>h<C-w><C-w>h<C-w>h

map <RightMouse> :set scrolloff=20<cr>
map <RightDrag> <LeftMouse>
map <RightRelease> :set scrolloff=1<cr>

map <MouseDown> <C-Y>
map <S-MouseDown> <C-U>
map <MouseUp> <C-E>
map <S-MouseUp> <C-D>

map <Home> <C-W><C-K>
map <End> <C-W><C-J>
map <S-Home> <C-W><C-L>
map <S-End> <C-H><C-H>


" Don't use Ex mode, use Q for formatting
map Q gq

" This is an alternative that also works in block mode, but the deleted
" text is lost and it only works for putting the current register.
"vnoremap p "_dp

" Only do this part when compiled with support for autocommands.
if has("autocmd")

  " Enable file type detection.
  " Use the default filetype settings, so that mail gets 'tw' set to 72,
  " 'cindent' is on in C files, etc.
  " Also load indent files, to automatically do language-dependent indenting.
  filetype plugin indent on

  " Put these in an autocmd group, so that we can delete them easily.
  augroup vimrcEx
  au!

  " For all text files set 'textwidth' to 78 characters.
  autocmd FileType text setlocal textwidth=78

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

  augroup END

else

  set smartindent		" always set autoindenting on

endif " has("autocmd")

colorscheme kristopolous

autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1

let g:closetag_html_style=1 
au Filetype html,xml,xsl source ~/.vim/autoload/closetag.vim 
